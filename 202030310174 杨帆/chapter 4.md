Copyright ©2021-2099 Fan Yang. All rights reserved

# 感想：

## 1. 当你需要一个高度重合的类时，当然可以重新定义个类，把所有的信息都放进去。但显然，人类这种懒惰的人不想这么做。于是，就诞生了派生类。:blush:

## 2. 通过这一时间的学习，我不仅学会了书本上的知识，而且往后预习，学到了STL与模板的知识，而且我对新知识加以运用，已经实现了几个较为复杂的项目。:+1:

## 3. 通过这段时间的C++学习，我加深了C++继承与派生知识的理解，同时也学会了从其他的网站（如CSDN）获得自己想要的资源的能力。

## 4. 保护成员的意思是，不能被外界引用，但可以被派生类的成员引用，有点类似于遗产。

## 5. 通过这段时间的学习，我领略到C++的更广泛用处，使用到了一些开源代码和开源库，我的编程思维得到极大锻炼。

## 6. 本章我们学了继承与派生，我也学会了利用继承让程序更加精简，继承是C++的精髓之一，在此期间，我的编程水平进一步提高，可以使用模板和STL自己独立开发一些项目 :rose:

# 课后题：

## 4.1

- private：这是C++中默认的继承方式，派生类可以访问基类的公有和保护成员，并将它们调整为本身的私有成员，但不可访问基类的私有成员。
- public:派生类不改变基类成员的访问属性，派生类可以访问基类的公有和保护成员，但不可访问基类的私有成员。
- protected：派生类将基类的公有成员转换为自身的保护成员，可以访问基类的公有和保护成员，但不可访问基类的私有成员。

## 4.2

不能。

- 不过可以在基类里面增加公有的setxx和getxx方法，在子类里面通过这些getxx和setxx方法间接访问基类的私有成员变量。
- 可以通过友元函数访问

## 4.3

继承方式：

- private: 继承成员但没有访问权限。
- protected: 继承成员，有访问权限，类外没有访问权限，不可将继承的protected修改为private.
- public: 继承成员，有访问权限，类外有访问权限。
  如果类A有private成员被继承后不可被类B访问，但可以通过类A有的protected或者public的成员函数间接访问。

## 4.4

- 构造函数是先执行父类的构造函数，再执行类中其他类对象的构造函数，再执行本类的构造函数。如果同级有多个构造函数，则按声明顺序执行。
- 析构函数与构造函数的执行顺序刚好相反。

## 4.5

'''
派生类名（参数总表）：基类名（参数总表）
{
    派生类参数语句;
}
''

## 4.6

派生类构造函数的执行顺序是先执行所有基类的构造函数（顺序按照定义派生类时指定的各基类顺序），再执行派生类的构造函数，析构函数执行顺序，与构造函数完全相反（因为，数据是按栈存储的）。

## 4.7

- 当引用派生类的成员时，首先在派生类自身的作用域中寻找这个成员，如果没有找到，则到它的基类中寻找。如果一个派生类是从多个基类派生出来的，而这些基类又有一个共同的基类，则在这个派生类中访问这个共同的基类中的成员时，可能会产生二义性。为了解决这种二义性，C ++引人了虚基类的概念。
- 虚基类的初始化与一般的多继承的初始化在语法上是一样的，但构造函数的调用顺序不同。在使用虚基类机制时应该注意以下几点：

1. 如果在虚基类中定义有带形参的构造函数，并且没有定义默认形式的构造函数，则整个继承结构中，所有直接或间接的派生类都必须在构造函数的成员初始化表中列出对虚基类构造函数的调用，以初始化在虚基类中定义的数据成员。
2. 建立一个对象时，如果这个对象中含有从虚基类继承来的成员，则虚基类的成员是由最远派生类的构造函数通过调用虚基类的构造函数进行初始化的。该派生类的其他基类对虚基类构造函数的调用都
   自动被忽略。
3. 若同一层次中同时包含虚基类和非虚基类，应先调用虚基类的构造函数，再调用非虚基类的构造函数，最后调用派生类构造函数。
4. 对于多个虚基类，构造函数的执行顺序仍然是先左后右，自上而下。
5. 对于非虚基类，构造函数的执行顺序仍是先左后右，自上而下。
6. 若虚基类由非虚基类派生而来，则仍然先调用基类构造函数，再调用派生类的构造函数

## 4.8

**A**

## 4.9

**C**

## 4.10

**C**

## 4.12

~~~
Constructor B1.
Constructor B2.
Constructor A.
3
2
1
~~~