# 算法与数据结构课程报告

作者：徐凌峰

日期：2020/12/13

## 概述

上课教的内容基本都会，代码也是一次搞定，简单调试之后就能通过，故在此只谈谈对老师源代码的改进

## 改进

### 1.枚举结构体类型代替int作为Status的类型

```c++
typedef enum {
	INFEASIBLE = -1,
	ERROR = 0,
	OK = 1
}Status;

/*
@brief			初始化顺序表
@param	list:	引用顺序表地址
@return			状态
*/
Status InitSqList(SqListPtr list);
```

"Status"可以作为类型，返回"ERROR"，"OK"等枚举型。

### 2.明确参数的拷贝传递和引用传递

```c++
typedef struct {
	ElemType* elem;
	int length;
	int size;
}SqList;

typedef SqList* SqListPtr;

/*
@brief			初始化顺序表
@param	list:	引用顺序表地址
@return			状态
*/
Status InitSqList(SqListPtr list);

/*
@brief			将两个顺序表合并并返回新顺序表
@param	list1:	顺序表1
@param	list2:	顺序表2
@return			合并后的新顺序表
*/
SqList MergeSqList(SqList list1, SqList list2);
```

其中，我定义了一个"SqList*"的指针类型"SqListPtr"，在需要引用的时候使用"SqListPtr"，拷贝则直接使用"SqList"。并且这里认为对指针的指针引用并不科学，而C语言中使用引用传递符号'&'也并不科学。为什么这里使用拷贝传递而不用"const SqListPtr"来确保非引用性？可能是这样做bug有点多。。。

### 3.针对链表中插入和查找循环结构的改进

```c++
Status InitLinkList(LinkListPtr head) {
	head = (LinkListPtr)malloc(sizeof(LinkList));
	// 不加内存判断，会有“取消对NULL指针的‘ListHead’的引用”的警告
	if (!(head)) exit(OVERFLOW);

	head->elem = 0;
	head->next = NULL;

	return OK;
}

Status LinkList_Insert(LinkListPtr head, int index, ElemType elem) {
	if (!head || !head->next) return ERROR;
	Node* prevNode;
	int prevIndex = 0;

	prevNode = head;
	while (prevNode && prevIndex < index - 1) {
		prevIndex++;
		prevNode = prevNode->next;
	}
	
    // 若已经找到了链表尾才退出循环，则表明没有找到指定的索引位置，此时应该返回错误
	if (!prevNode) return ERROR;

	Node* newNode = (Node*)malloc(sizeof(Node));
	if (!newNode) exit(OVERFLOW);
	
	newNode->elem = elem;
	newNode->next = prevNode->next;
	prevNode->next = newNode;
	return OK;
}
```

### 4.针对栈和队列结构体的改进

```c++
typedef struct stack {
	LinkList list;
}Stack;
```

既然栈也是链表结构，为何不直接包含一个链表，就像C++的继承一样？Stack的一系列函数直接封装对成员list的操作。

总之拿C语言来学数据结构就NM离谱。使用C++，你就可以得到完美的封装的数据结构。

```c++
namespace struction {

	template<typename ElemType>
	class LinkList {
	protected:
		typedef uint32_t typename Status;
		typename Status ERROR = 0;
		typename Status OK = 1;

	public:
		LinkList();

		Status init();

		Status clear();

		//Status destroy();

		Status traverse();

		bool empty();

		int length();

		ElemType get();

		int locate();

		Status insert();

		Status erase();

		// 友元函数，允许外部函数访问内部成员
		friend LinkList<ElemType> create(int length);

	private:
		typedef struct Node Node;
		struct Node {
			ElemType elem;
			Node* next;
		};
		Node* head;
	};

	template<typename ElemType>
	LinkList<ElemType> create(int length);
}
```

