感想
经过上机实操后，对C++的认识程度提高了，在增加了编程经验的同时掌握了更多的编程技巧，C++学习起来也更加得心应手了。
就拿这此作业而言，有了之前的上机经验后，其中读程序的题对我而言变得极为简明。
综上所述上机是可以提高我们的对程序的理解能力的。
不仅如此，通过这次作业和之前的学习，我还明白了许多继承与类相关的知识，简要总结如下。
继承是面向对象程序设计的一个重要特性,它允许在已有类的基础上创建新的类,新类可以从一个或多个已有类中继承函数和数据,而且可以重新定义或加进新的数据和函数,从而形成类的层次或等级。
其中已有类称为基类或父类,在它基础上建立的新类称为派生类或子类。



4.1
公有继承,私有继承和保护继承。
基类的私有成员,无论哪种继承方式都不能访问。
公有继承不改变基类的公有和保护成员的访问限制。
私有继承将基类的公有和保护成员都变成公有。
保护继承将基类的公有和保护成员都变成保护。
4.2
不能。可以在基类里添加一个公有成员函数来访问私有成员派生类就能继承这个公有成员函数,实现对基类私有成员的访问。
4.3
保护成员只能被本类或本类的派生类所访问,在类或派生类外是不能被访问的。
基类的私有成员,无论哪种继承方式都不能访问。
公有继承不改变基类的公有和保护成员的访问限制。
私有继承将基类的公有和保护成员都变成公有。
保护继承将基类的公有和保护成员都变成保护。
4.4
构造函数是先执行父类的构造函数,再执行类中其他类对象的构造函数,再执行本类的构造函数。如果同级有多个构造函数,则按声明顺序执行。
析构函数与构造函数的执行顺序刚好相反。
4.5
派生类名（参数总表) ：基类名(参数总表)
｛派生类新增数据成员的初始化语句
｝
派生类中的析构函数与基类无关。
4.6
多继承是指一个类同时继承自多个不同的基类。
执行顺序同4.4
4.7
如果一个类有多个直接基类,而这些直接基类又有一个共同的基类,则在最底层的派生类中会保留这个简介的共同基类数据成员的多份同名成员。在访问这些同名成员的时候,会产生二义性。为了解决三义性, 引入了虚基类。
（1)如果虚基类中定义有带形参的构造函数,并且没有定义默认形式的构造函数,则整个继承结构中,所有直接或间接的派牛类都必须在构造函数的成员初始化表中列出对虚基类构造函数的调用,以初始化在虚基类中定义的数据成员。
（2)建立一个对象时,如果这个对象中含有从虚基类继承来的成员,则虚基类的成员是由最远派生类的构造函数通过调用虚基类的构造函数进行初始化的。该派生类的其他基类对虚基类构造函数的调用都自动被忽略。
（3)若同一层次中同时包含虚基类和非虚基类,应先调用虚基类的构造函数,再调用非虚基类的构造函数,最后调用派生类的构造函数。
4.8
a
4.9
c
4.10
c
4.12
Constructor B1.
Constructor B2.
Constructor A.
3
2
1
